<#
Simple Vulnerability Scanner for PowerShell scripts.
This script scans one or more .ps1 files for risky/insecure patterns and reports matches.
It does NOT execute the target files â€” only reads them.

Usage:
    .\vulncheck.ps1 -Path .\test_target.ps1
    .\vulncheck.ps1 -Path C:\Scripts -Recurse
#>

param(
    [Parameter(Mandatory=$true, Position=0)]
    [string]$Path,

    [switch]$Recurse
)

$patterns = @{
    'Invoke-Expression (iex)' = '\b(Invoke-Expression|iex)\b'
    'DownloadString / WebClient' = '(DownloadString|New-Object\s+Net\.WebClient|WebClient)'
    'Start-Process powershell / cmd exe with encoded command' = '(Start-Process\s+.*(powershell|cmd).*(-EncodedCommand|-e)?)'
    'EncodedCommand/EncodedArgument' = '(EncodedCommand|Base64|FromBase64String)'
    'Add-Type / Reflection emit' = '\b(Add-Type|Reflection|AssemblyLoad)\b'
    'Out-File/Write-Exe to disk patterns' = '\b(Out-File|Set-Content|[Ww]rite-?All)\b.*(Exe|dll|\.exe|\.dll)'
    'Obfuscation: -join or -split with many parts' = '(-join\s+\(|-split\s+\()'
}

function Scan-File {
    param([string]$File)
    $content = Get-Content -Raw -LiteralPath $File -ErrorAction Stop
    $lines = $content -split "\r?\n"
    $results = @()
    foreach ($name in $patterns.Keys) {
        $regex = $patterns[$name]
        $matches = Select-String -InputObject $content -Pattern $regex -AllMatches -SimpleMatch:$false
        foreach ($m in $matches) {
            $results += [PSCustomObject]@{
                File = $File
                Pattern = $name
                MatchText = $m.Line.Trim()
                LineNumber = $m.LineNumber
            }
        }
    }
    return $results
}

$targets = @()
if (Test-Path $Path) {
    $attr = Get-Item $Path
    if ($attr.PSIsContainer) {
        if ($Recurse) {
            $targets = Get-ChildItem -Path $Path -Filter '*.ps1' -Recurse -File | Select-Object -ExpandProperty FullName
        } else {
            $targets = Get-ChildItem -Path $Path -Filter '*.ps1' -File | Select-Object -ExpandProperty FullName
        }
    } else {
        $targets = @((Resolve-Path -LiteralPath $Path).Path)
    }
} else {
    Write-Error "Path '$Path' not found"
    exit 2
}

$allResults = @()
foreach ($t in $targets) {
    try {
        $r = Scan-File -File $t
        if ($r) { $allResults += $r }
    } catch {
        # Use formatted string to avoid issues with colons in paths (e.g. C:\...)
        $errMsg = $_.Exception.Message
        Write-Warning ("Failed to read {0}: {1}" -f $t, $errMsg)
    }
}

if (-not $allResults) {
    Write-Host "No suspicious patterns found in target(s)." -ForegroundColor Green
    exit 0
}

Write-Host "Suspicious findings:" -ForegroundColor Yellow
$grouped = $allResults | Group-Object -Property File
foreach ($g in $grouped) {
    Write-Host "\nFile: $($g.Name)" -ForegroundColor Cyan
    foreach ($i in $g.Group) {
        Write-Host " [$($i.LineNumber)] $($i.Pattern): $($i.MatchText)"
    }
}

exit 1
